<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Winter Notes</title><link>https://winterggg.github.io/blog</link><description>不是博客，是个文摘</description><copyright>Winter Notes</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/92662575?v=4</url><title>avatar</title><link>https://winterggg.github.io/blog</link></image><lastBuildDate>Sat, 20 Apr 2024 15:35:14 +0000</lastBuildDate><managingEditor>Winter Notes</managingEditor><ttl>60</ttl><webMaster>Winter Notes</webMaster><item><title>Think twice, code once!</title><link>https://winterggg.github.io/blog/post/Think%20twice%2C%20code%20once%21.html</link><description># Think twice, code once!&#13;
&#13;
&gt; 本文取材自：https://brunokiafuka.substack.com/p/think-twice-code-once&#13;
&#13;
作者在做 code review 时发现一些新手程序员往往提交一些「拧巴」 的代码 -- 要么过度工程化，要么过度复杂. 作者通过询问，发现问题的关键似乎在于这些实现只是他们的第一个想法，他们并没有去认真分析这个实现是否恰当. &#13;
&#13;
针对这个问题，作者提供了一个软件开发工程的思考过程：&#13;
&#13;
1. **获取上下文**. 收集信息和需求，通过 5why 分析法充分理解上下文，理解代码变更的原因和影响；&#13;
&#13;
2. **写下假设**. 基于上一步对上下文的理解，提出假设（assumption）-- 即要做什么以及如何做，给出不同实现路径的优缺点并进行排序.  重复多次进行该步骤，但为了避免分心或失去焦点，需要限制假设的数量;&#13;
&#13;
3. **实现**. 从上一步的实现路径中选择一个去最终实现.&#13;
&#13;
   &#13;
&#13;
最后作者推荐了 Leslie Lamport 大佬的一个 talk，mark 了有空看看：https://www.youtube.com/watch?v=-4Yp3j_jk8Q&amp;ab_channel=MicrosoftResearch&#13;
&#13;
&#13;
&#13;
想法：&#13;
&#13;
我认为可以参考的地方有两个：&#13;
&#13;
1. 推迟编码：延迟编写代码直至充分理解问题和上下文，有助于减少在开发过程中可能出现的错误和误解；&#13;
2. 广度优先策略：在深入一个解决方案之前先广泛考虑多个可能的解决方案. 这种策略可以避免在错误的方向上投入太多资源，可以有效的减少返工和提高代码质量.&#13;
&#13;
感觉这个其实是一种风险管理策略在软件开发中的应用，之前刷油管有个博主说非商科专业出身的人往往缺乏风险管理的意识，之后有空了可以多看看这方面的案例分析.&#13;
&#13;
&#13;
&#13;
。</description><guid isPermaLink="true">https://winterggg.github.io/blog/post/Think%20twice%2C%20code%20once%21.html</guid><pubDate>Sat, 20 Apr 2024 15:30:50 +0000</pubDate></item><item><title>TC 39 和 JS proposal</title><link>https://winterggg.github.io/blog/post/TC%2039%20-he-%20JS%20proposal.html</link><description># TC 39 和 JS proposal&#13;
&#13;
TC39（Technical Committee 39）是负责ECMAScript标准化的组织，它是ECMA International的一部分，后者是一个致力于信息和通信系统标准化的国际私有组织. &#13;
&#13;
TC39 是一个由 JavaScript 开发者、实现者、学者等组成的团体，与 JavaScript 社区合作维护和发展 JavaScript 的标准，ECMAScript是JavaScript的官方标准. &#13;
&#13;
总的来说，JavaScript 的标准库相对较小，但 TC39 的一个趋势是使 JS 成为一种“内置电池（batteries-included）”的语言，提供高质量的内置功能集. 例如，[Temporal](https://github.com/tc39/proposal-temporal) 正在取代 moment.js，一些小功能，如 `Array.prototype.flat` 和 `Object.groupBy` 正在取代许多 lodash 的使用场景. &#13;
&#13;
&#13;
&#13;
[JavaScript提案（JS proposal）](https://www.proposals.es/) 是指任何希望被加入ECMAScript标准的新功能、语法或者API的正式建议. 提案通过一系列的阶段，从一个初步想法发展成为标准的一部分. &#13;
&#13;
在讨论TC39和JavaScript提案时，有几个常见的术语：&#13;
&#13;
1. **ECMAScript (ES)**: JavaScript的官方名称和标准，由TC39维护. &#13;
2. **Proposal**: 一个提议，它旨在引入新的功能或对现有功能进行更改. &#13;
3. **Champion**: 一个或一组TC39委员会成员，他们将某个提案视为有价值，并愿意承担起推动提案前进的责任. 他们会在TC39会议上代表提案，回答问题，处理反馈，并且确保提案在整个过程中不断进展. 通常，一个提案至少需要一个champion，但有时一个提案可能有一个小组的champion，尤其是对于复杂或者重要的更改. &#13;
4. **Strawperson (Stage 0)**: 提案的最初阶段，用于讨论和收集对新特性的反馈. 任何想法都可以被当作Stage 0的提案，不需要形式化的规范. &#13;
5. **Proposal (Stage 1)**: 提案已经正式提交并获得一位或多位champion的支持，提供了初步的规范草案和问题讨论，包括一个高级别的语言描述、示例、API、语义和算法等. &#13;
6. **Draft (Stage 2)**: 提案有了初步的规范，并且不太可能有大的变化. 开发者和其他利益相关者开始关注提案的细节. &#13;
7. **Candidate (Stage 3)**: 提案规范文本基本完成，并且已经有了多个实验性实现. 在这个阶段，提案需要实际的反馈来确定是否准备好成为标准的一部分. &#13;
8. **Finished (Stage 4)**: 提案已经完成，在两个独立的实现中被证明是可行的，并且至少有一个通过了所有正式的ECMAScript兼容性测试套件（Test262）. 一旦提案达到这个阶段，就会被加入下一个版本的ECMAScript标准. &#13;
9. **Consensus**: TC39的决策过程基于共识，这意味着提案必须取得委员会成员的普遍同意才能前进. &#13;
10. **Polyfill/Shim**: 一个用来在老版本的JavaScript引擎中模拟新特性的代码片段，使得开发者可以提前使用新特性，而不用等到所有用户的浏览器都支持这些特性. &#13;
11. **Transpiler**: 一个转换编译器，比如Babel，它能够将使用新ECMAScript特性的代码转换成向后兼容的JavaScript版本，以便可以在当前的JavaScript环境中运行. &#13;
12. **Test262**: ECMA International维护的 ECMAScript [官方测试套件](https://github.com/tc39/test262)，用于验证符合性和实现的正确性.。</description><guid isPermaLink="true">https://winterggg.github.io/blog/post/TC%2039%20-he-%20JS%20proposal.html</guid><pubDate>Tue, 02 Apr 2024 05:24:07 +0000</pubDate></item><item><title>论文笔记 SQLite: Past, Present, and Future</title><link>https://winterggg.github.io/blog/post/lun-wen-bi-ji-%20SQLite-%20Past%2C%20Present%2C%20and%20Future.html</link><description># 论文笔记 SQLite: Past, Present, and Future&#13;
&#13;
- 论文名称：SQLite: past, present, and future&#13;
&#13;
- 作者单位：威斯康星大学麦迪逊分校 (University of Wisconsin-Madison)的三名研究人员和 Sqlite 社区的三名贡献者&#13;
- 发表期刊：VLDB Endowment（数据库领域三大顶会之一），01 August 2022&#13;
&#13;
# TL; DR&#13;
&#13;
这篇论文 novelty 比较一般，主要跑了几个 benchmark 然后基于测试场景提出了一个奇奇怪怪的优化方法. 但对 SQLite 的一些介绍和分析比较全面，因此也是比较值得阅读的. &#13;
&#13;
# 历史与架构&#13;
&#13;
## 历史&#13;
&#13;
SQLite自2000年首次发布以来，已成为最广泛部署的数据库引擎之一，存在于几乎所有智能手机、计算机、网络浏览器、电视和汽车中.&#13;
&#13;
它的普及归功于其跨平台，自包含和极小的 release 体积，可靠和快速.&#13;
&#13;
## 引擎架构&#13;
&#13;
### 模块&#13;
&#13;
&lt;img width="490" alt="image-20240331192521985" src="https://github.com/winterggg/blog/assets/92662575/1f972de5-607a-4398-9e71-3ae970095d88"&gt;&#13;
&#13;
如图，SQLite 使用了模块化的设计. 它的架构包括SQL编译器模块、核心模块、后端模块和一些辅助模块，如测试代码和实用工具.&#13;
&#13;
&lt;img width="339" alt="image-20240331193253026" src="https://github.com/winterggg/blog/assets/92662575/8f3480c9-9630-4679-b3f1-d976da2eb53a"&gt;&#13;
&#13;
&#13;
- core modules. 核心模块负责接收和执行SQL语句. &#13;
  - SQLite 的虚拟机又叫 virtual database engine (VDBE)，是  SQLite 的核心. 其执行代码的过程其实类似于 JVM，略.&#13;
- SQL compiler modules. SQL编译器模块将SQL语句转换为字节码程序，该程序可以由虚拟机执行. &#13;
  - 可以把每个 SQL statement 看做一个源码. SQLite 就像一个编译器一样，拥有 Tokenizer、Parser 和 Code Generator，将 SQL statement 转换为 bytecode. Bytecode 如上图所示，包括 opcode 和 oprands，例如 Column 就是从当前行取某一列的值存入寄存器. &#13;
- backend modules. 后端模块用于访问数据库页并与 OS 交互以持久化数据. &#13;
  - VDBE 高强度和 backend 交互，主要是在操作 B 树.&#13;
- accessory modules. 包括超大规模的测试代码和一些实用工具，例如用于内存分配、字符串操作和随机数生成.&#13;
&#13;
### backend 细节&#13;
&#13;
**B树**&#13;
&#13;
SQLite 数据库文件本质上是B树的集合. 分为两种：表B树和索引B树&#13;
&#13;
- 表B树（Table B-trees）：&#13;
  - 使用64位有符号整数作为键（key）;&#13;
  - 数据存储在叶节点中. &#13;
- 索引B树（Index B-trees）：&#13;
  - 使用任意键.&#13;
  - 不存储数据.&#13;
&#13;
**数据库表的表示**&#13;
&#13;
- 数据库中每个表都由一个表B树表示. &#13;
- 表B树的键是表的隐式`rowid`列. &#13;
- 对于`INTEGER PRIMARY KEY`表，主键列取代`rowid`成为B树的键. &#13;
- 声明为 `WITHOUT ROWID`的表是特殊情况：&#13;
  - 这些表完全存储在索引B树中. &#13;
  - `WITHOUT ROWID`表的B树键由主键列组成，然后是表的所有剩余列. &#13;
- 数据库架构中的每个索引都有一个索引B树，除非索引已由表B树表示，如`INTEGER PRIMARY KEY`表的情况. &#13;
&#13;
**页缓存（Page Cache）**&#13;
&#13;
- 页缓存负责提供B树模块请求的数据页. &#13;
- 页缓存还负责确保修改过的页能够安全且高效地刷新（flush）到稳定存储中. &#13;
&#13;
**操作系统接口**&#13;
&#13;
- SQLite使用一个称为虚拟文件系统（VFS）的抽象对象来跨操作系统提供可移植性. &#13;
- SQLite为Unix和Windows操作系统提供了几种现成的VFS. &#13;
- 可以通过创建 VFS 来支持新的操作系统或扩展SQLite的功能. &#13;
&#13;
**值提取**&#13;
&#13;
- **灵活的类型系统**：SQLite允许任何类型的数据存储在任何列中（INTEGER PRIMARY KEY列除外）. &#13;
- **列声明灵活性**：SQLite中可以创建没有数据类型声明的列，如 `CREATE TABLE t (a, b, c);`. &#13;
- **类型信息存储**：每个值旁边都会存储类型信息，SQLite记录分为头部和主体，头部包含数据类型编码，主体包含实际值. &#13;
- **值提取过程：**&#13;
  - **查找过程**：通过检查记录头部的指针，确定值的位置，头部包含每列数据类型的序列化类型码. &#13;
  - **计算偏移量**：SQLite遍历头部的类型码，累加每个值的大小来计算所需值的偏移量. &#13;
- 这种方式（无数据类型声明）的一个缺点是不能很好的压缩，占用空间也比较大，COLUMN 字节码指令的效率也相对较低. &#13;
&#13;
### 事务&#13;
&#13;
**事务性数据库引擎**&#13;
&#13;
- SQLite 是一个事务性数据库引擎. &#13;
- 它提供了原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）的ACID保证. &#13;
- **SQLite 提供了 2 种可选的事务模式**：回滚模式（Rollback Mode）和预写日志模式（Write-Ahead Log Mode, WAL）. &#13;
&#13;
**回滚模式（Rollback Mode）**&#13;
&#13;
- 开始事务时，SQLite获取数据库文件的共享锁. &#13;
- 获取共享锁后，可以随意读取数据库页. &#13;
- 如果事务涉及更改，SQLite将读锁升级为保留锁（reserved lock），阻止其他写入者，但允许读取者继续. &#13;
- 更改前，SQLite创建回滚日志文件(rollback journal file). &#13;
- SQLite将每个将要修改的页的原始内容写入回滚日志，并在用户空间保留更新的页. &#13;
- 提交事务时，SQLite将回滚日志刷新到稳定存储. &#13;
- 然后获取数据库文件的排他锁，阻止读写者，并应用更改. &#13;
- 更新的数据库页刷新到稳定存储后，回滚日志有多种失效方式，具体取决于日志模式：&#13;
  - 在DELETE模式中，SQLite删除回滚日志. &#13;
  - 因为某些系统上删除文件代价高昂，SQLite也提供了其他日志模式. &#13;
  - TRUNCATE模式下，回滚日志被截断而非删除. &#13;
  - PERSIST模式下，回滚日志的头部被覆盖为零. &#13;
- 使回滚日志失效实际上等同于提交事务. &#13;
- 最后，SQLite释放数据库文件的排他锁. &#13;
&#13;
&#13;
&#13;
**预写日志模式（Write-Ahead Log Mode, WAL）**&#13;
&#13;
- 概念上，WAL模式是回滚模式的反转. &#13;
- 回滚模式中，SQLite将原始页写入回滚日志，修改后的页写入数据库文件. &#13;
- WAL模式保留数据库文件中的原始页，并将修改后的页附加到单独的WAL文件. &#13;
- WAL模式下，事务开始时记录WAL中最后一个有效提交记录的位置，称为结束标记(end mark). &#13;
- 需要页时，SQLite在WAL中搜索结束标记之前该页的最新版本. &#13;
- 如果WAL中没有该页，SQLite从数据库文件中检索. &#13;
- 变更仅仅被追加到WAL的末尾. (即追加写)&#13;
- WAL增长超过指定大小**会触发检查点**，此时WAL中更新的页写回数据库文件. &#13;
- 检查点后，WAL文件不会被删除，而是起始部分被后续事务覆写. &#13;
&#13;
**WAL模式的优势**&#13;
&#13;
1. 增加并发性：读取者可以在写入者将更改提交到WAL时继续操作数据库. &#13;
2. 速度：通常更快，因为它需要较少的落盘操作，且写入操作更加顺序. （大概就是 commit 前可以享受内存的性能或者说追加写的性能）&#13;
&#13;
**WAL模式的劣势**&#13;
&#13;
- 为加速搜索WAL，SQLite在共享内存中创建WAL索引，这提高了读事务的性能，**但要求所有读取者必须在同一台机器上.** &#13;
- 因此，WAL模式不适用于网络文件系统. &#13;
- 进入WAL模式后无法更改页大小. &#13;
- WAL模式增加了检查点操作的复杂性和存储WAL及WAL索引的额外文件&#13;
&#13;
# 运行硬件和工作负载的演变&#13;
&#13;
- 硬件的进步和软件需求的变化对SQLite提出了新的挑战. &#13;
- 尽管SQLite主要用于OLTP，但它也被用于处理复杂的OLAP查询和边缘计算场景. （好像是对一个移动设备进行 trace 得出的结论）.&#13;
- SQLite 的行存储格式和执行引擎对许多 OLAP 操作来说并不是最佳选择&#13;
&#13;
作者这里举了个例子，说现在的科研人员其实都有这样一个广泛的需求，就是在上线大模型前在本地 in-process 的快速跑一些 OLAP 查询，比如比较常见的就是用 pandas 跑一些数据分析任务，但这些库的效率其实是很低的，作者认为 sqlite 这种嵌入式数据引擎在这方面未来大有可为.&#13;
&#13;
# 性能测试和优化&#13;
&#13;
这一部分主要是一些基准测试，图表比较多也有些无聊，这里摘一些主要结论. &#13;
&#13;
## TATP 吞吐测试（OLTP 领域）&#13;
&#13;
- **SQLite-WAL 性能：**&#13;
  - 在两种硬件配置上均显示出最高的吞吐量. &#13;
  - 在云服务器上：达到了10,000 TPS，相较于DuckDB的性能优势为：&#13;
    - 小型数据库快了10倍. &#13;
    - 大型数据库快了500倍. &#13;
  - 在树莓派上：&#13;
    - 对于小型数据库比DuckDB快2倍. &#13;
    - 对于大型数据库快60倍. &#13;
- **SQLite-DELETE 性能：**&#13;
  - **比SQLite-WAL慢**，但在云服务器上显著快于DuckDB. &#13;
  - 在树莓派上：&#13;
    - DuckDB对小型数据库的性能略胜于SQLite-DELETE. &#13;
    - 对于大型数据库，SQLite-DELETE更快. &#13;
- **性能一致性：**&#13;
  - SQLite-WAL和SQLite-DELETE不管数据库大小如何，都显示出了较为一致的性能. &#13;
  - DuckDB的性能随数据库大小增加而下降. &#13;
- **一般观察：**&#13;
  - SQLite的性能归功于其多年来精心调优的事务处理机制. &#13;
  - DuckDB，主要为OLAP和ETL工作负载设计，展现出在TATP（事务型）基准测试上的性能明显较差. &#13;
- **挖坑：**&#13;
  - 作者在这里挖了个坑，说俺之后会研究下，这个性能差异是由于实现细节还是系统架构的根本差异.&#13;
&#13;
## SSB 吞吐测试（OLAP）&#13;
&#13;
- DuckDB在所有查询中都明显快于SQLite. &#13;
- DuckDB在部分查询中的性能优势巨大，快了30-50倍；在部分查询中优势最小，快了3-8倍. &#13;
- SQLite在不同查询中的延迟差异较大.&#13;
- 在树莓派上，SQLite最快的查询比最慢的快10倍；而DuckDB最快的查询仅比最慢的快3倍. &#13;
&#13;
## 进一步优化&#13;
&#13;
作者开启编译时选项 VDBE_PROFILE 输出了 VDBE 执行每个字节码指令所消耗的 CPU 周期数. 发现只有两个指令（SeekRowid和Column）占了大多数 CPU 周期：&#13;
&#13;
- SeekRowid 指令在B树索引中搜索具有给定行ID的行. &#13;
- Column 指令从给定记录中提取列. &#13;
&#13;
然后分别水了下优化方法：&#13;
&#13;
- 针对第一个问题，发现是 join 效率的问题，解决方法是给 Inner loop 的表上了个布隆过滤器实现了一个 Lookahead Information Pass- ing (LIP)，这样在基准测试场景能避免一些 seekRowid... 另外还有 hash Joins 的方法，但可以预见的内存消耗不可控，抛了.&#13;
- 针对第二个问题，作者想了几个办法但由于会担心破坏稳定性，抛了（原话）&#13;
&#13;
## Blob 测试&#13;
&#13;
就是测试下二进制文件存储，和 fread/fdatasync 还有 duckdb 测试，感觉比较迷我直接跳了. &#13;
&#13;
# 一些有意思的信息&#13;
&#13;
1. 最初作为Tcl编程语言的扩展打包，SQLite诞生于对在另一个独立进程中运行的数据库服务器进行调试时的沮丧之情.&#13;
2. 据估计，目前可能有超过**一万亿**个正在使用的SQLite数据库. 据估计，SQLite是最广泛部署的软件库之一.&#13;
3. SQLite 是一个真正的工业级别数据库：SQLite 代码是一个 15 万行的单个 C 语言，但测试代码和脚本居然有九千多万行. 每行SQLite代码中有超过600行的测试代码. 测试覆盖库中100%的分支. 测试套件非常多样化，包括模糊测试、边界值测试、回归测试以及模拟操作系统崩溃、断电、I/O错误和内存不足等各种情况的测试.&#13;
4. 由于 SQLite 的变态测试覆盖率，给 SQLite 添加功能变得非常惬意，不用太担心对现有功能造成影响.&#13;
5. 删除操作比其他语句更加耗费资源，平均每个语句约为4毫秒. &#13;
6. 对于排序大量数据，SQLite使用可选的多线程外部合并排序算法. &#13;
7. 测试技巧：测试前可以用 SELECT * query populate 以下 buffer pool 以及 测试前可以先预热几秒钟再统计.&#13;
8. sqlite 文件格式是美国国会图书馆推荐的数字内容保存格式.&#13;
9. SQLite也有广泛的文档和注释，这有助于新开发人员快速理解SQLite的架构. &#13;
&#13;
。</description><guid isPermaLink="true">https://winterggg.github.io/blog/post/lun-wen-bi-ji-%20SQLite-%20Past%2C%20Present%2C%20and%20Future.html</guid><pubDate>Sun, 31 Mar 2024 12:38:18 +0000</pubDate></item><item><title>最糟糕的程序员</title><link>https://winterggg.github.io/blog/post/zui-zao-gao-de-cheng-xu-yuan.html</link><description># 最糟糕的程序员&#13;
&#13;
&gt; 本文取材自 http://mikhailian.mova.org/node/284&#13;
&#13;
这篇文章给出了一个非常有意思的思考：我们行业中最优秀的人往往可能是最糟糕的。</description><guid isPermaLink="true">https://winterggg.github.io/blog/post/zui-zao-gao-de-cheng-xu-yuan.html</guid><pubDate>Sat, 30 Mar 2024 16:23:56 +0000</pubDate></item><item><title>AsyncLocalStorage 源码分析</title><link>https://winterggg.github.io/blog/post/AsyncLocalStorage%20-yuan-ma-fen-xi.html</link><description># AsyncLocalStorage 源码分析&#13;
&#13;
## TL; DR&#13;
&#13;
本文概述了 `AsyncLocalStorage` 的概念和它在 Node.js 中的历史发展。</description><guid isPermaLink="true">https://winterggg.github.io/blog/post/AsyncLocalStorage%20-yuan-ma-fen-xi.html</guid><pubDate>Sat, 30 Mar 2024 15:18:06 +0000</pubDate></item><item><title>学习与职业生涯规划 - the missing readme</title><link>https://winterggg.github.io/blog/post/xue-xi-yu-zhi-ye-sheng-ya-gui-hua-%20-%20the%20missing%20readme.html</link><description># 学习与职业生涯规划&#13;
&#13;
&gt; 本文取材自《The missing readme》-- Chapter 10/14&#13;
&#13;
## 学习如何学习&#13;
&#13;
- 编写、调试代码&#13;
- 阅读： 团队文档、设计文档、代码、积压的Jira任务、书籍、论文和技术网站。</description><guid isPermaLink="true">https://winterggg.github.io/blog/post/xue-xi-yu-zhi-ye-sheng-ya-gui-hua-%20-%20the%20missing%20readme.html</guid><pubDate>Thu, 28 Mar 2024 04:44:07 +0000</pubDate></item><item><title>如何做方案设计 - the missing readme</title><link>https://winterggg.github.io/blog/post/ru-he-zuo-fang-an-she-ji-%20-%20the%20missing%20readme.html</link><description># 如何做方案设计&#13;
&#13;
&gt; 本文取材自《The missing readme》-- Chapter 10&#13;
&#13;
软件设计不是一个线性的过程，更像是在独立工作和相互合作之间交替进行的螺旋式上升的过程，在每一步都要明确和完善设计。</description><guid isPermaLink="true">https://winterggg.github.io/blog/post/ru-he-zuo-fang-an-she-ji-%20-%20the%20missing%20readme.html</guid><pubDate>Thu, 28 Mar 2024 04:43:41 +0000</pubDate></item><item><title>编码与测试 - the missing readme</title><link>https://winterggg.github.io/blog/post/bian-ma-yu-ce-shi-%20-%20the%20missing%20readme.html</link><description># 编码与测试&#13;
&#13;
&gt; 本文取材自《The missing readme》-- Chapter 3/6&#13;
&#13;
## 混乱的根源&#13;
&#13;
**1/ 软件的熵**&#13;
&#13;
代码走向无序的趋势被称为软件的熵（entropy）。</description><guid isPermaLink="true">https://winterggg.github.io/blog/post/bian-ma-yu-ce-shi-%20-%20the%20missing%20readme.html</guid><pubDate>Thu, 28 Mar 2024 04:34:07 +0000</pubDate></item><item><title>代码评审 - the missing readme</title><link>https://winterggg.github.io/blog/post/dai-ma-ping-shen-%20-%20the%20missing%20readme.html</link><description># 代码评审&#13;
&#13;
&gt; 本文取材自《The missing readme》-- Chapter 6&#13;
&#13;
## 当你是被评审者&#13;
&#13;
### 精心准备&#13;
&#13;
你的目的是让评审者**理解你在做什么**以及提供有建设性的反馈，有些建议可以遵循：&#13;
&#13;
1. 提交 pr 前确保通过了 test 和 lint；&#13;
2. 单次 pr 的改动不要太大；&#13;
3. 将 feature 和 refactor 分到不同的 pr 里；&#13;
4. 需要给出描述性的提交信息；&#13;
5. 务必将注释和测试包括在内；&#13;
6. 不要**守护**你提所交的代码，要期待它在评审中发生变化，有时候甚至是巨大的变化。</description><guid isPermaLink="true">https://winterggg.github.io/blog/post/dai-ma-ping-shen-%20-%20the%20missing%20readme.html</guid><pubDate>Thu, 28 Mar 2024 04:32:52 +0000</pubDate></item><item><title>Hello, world</title><link>https://winterggg.github.io/blog/post/Hello%2C%20world.html</link><description># H1&#13;
&#13;
## H2&#13;
```&#13;
2024 年 03 月 24 日 19:26:54&#13;
```。</description><guid isPermaLink="true">https://winterggg.github.io/blog/post/Hello%2C%20world.html</guid><pubDate>Sun, 24 Mar 2024 11:27:27 +0000</pubDate></item></channel></rss>